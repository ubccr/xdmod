<?php

namespace DataWarehouse\Export;

use CCR\Loggable;
use DataWarehouse\Data\BatchDataset;
use DataWarehouse\Data\RawStatisticsConfiguration;
use DataWarehouse\Export\FileWriter\FileWriterFactory;
use Exception;
use Log;
use ZipArchive;
use xd_utilities;

/**
 * Manages data warehouse batch export file related functionality.
 */
class FileManager extends Loggable
{
    // Constants used in log messages.
    const LOG_MODULE = 'data-warehouse-export';

    /**
     * Data warehouse batch export directory path.
     *
     * This is directory where zip files are stored after they are generated by
     * the batch process.
     *
     * @var string
     */
    private $exportDir;

    /**
     * Factory instance for creating file writers.
     * @var \DataWarehouse\Export\FileWriter\FileWriterFactory
     */
    private $fileWriterFactory;

    /**
     * Raw statistics configuration.
     * @var \DataWarehouse\Data\RawStatisticsConfiguration;
     */
    private $rawStatsConfig;

    /**
     * Construct a new file manager.
     *
     * @throws \Exception If the data warehouse export directory is not set.
     */
    public function __construct(Log $logger = null)
    {
        // Must set properties that are used in `setLogger` before calling the
        // parent constructor.
        $this->fileWriterFactory = new FileWriterFactory($logger);
        parent::__construct($logger);

        $this->rawStatsConfig = RawStatisticsConfiguration::factory();

        try {
            $this->exportDir = xd_utilities\getConfiguration(
                'data_warehouse_export',
                'export_directory'
            );
        } catch (Exception $e) {
            $this->logger->err([
                'module' => self::LOG_MODULE,
                'message' => $e->getMessage(),
                'stacktrace' => $e->getTraceAsString()
            ]);
            throw new Exception('Export directory is not configured', 0, $e);
        }

        if (!is_dir($this->exportDir)) {
            throw new Exception(sprintf(
                'Export directory "%s" does not exist',
                $this->exportDir
            ));
        }

        if (!is_readable($this->exportDir)) {
            throw new Exception(sprintf(
                'Export directory "%s" is not readable',
                $this->exportDir
            ));
        }
    }

    /**
     * Set the logger for this object.
     *
     * @see \CCR\Loggable::setLogger()
     * @param \Log $logger A logger instance or null to use the null logger.
     * @return self This object for method chaining.
     */
    public function setLogger(Log $logger = null)
    {
        parent::setLogger($logger);
        $this->fileWriterFactory->setLogger($logger);
        return $this;
    }

    /**
     * Get the batch export data file path.
     *
     * This is the path of the file that will be used to store the export data on
     * the Open XDMoD server after it has been generated.
     *
     * @param intger $id Batch export request primary key.
     * @return string
     */
    public function getExportDataFilePath($id)
    {
        return sprintf('%s/%s.zip', $this->exportDir, $id);
    }

    /**
     * Get the batch export data file name.
     *
     * This is the name that will be used by the file that contains the
     * exported data.
     *
     * @param array $request Batch export request data.
     * @return string
     */
    public function getDataFileName(array $request)
    {
        return sprintf(
            '%s--%s-%s.%s',
            $request['realm'],
            $request['start_date'],
            $request['end_date'],
            strtolower($request['export_file_format'])
        );
    }

    /**
     * Get the batch export zip file name.
     *
     * This is the name that will be used when the file is downloaded by a
     * user.
     *
     * @param array $request Batch export request data.
     * @return string
     */
    public function getZipFileName(array $request)
    {
        return sprintf(
            '%s--%s-%s.zip',
            $request['realm'],
            $request['start_date'],
            $request['end_date']
        );
    }

    /**
     * Write a data set to a temporary file.
     *
     * @param \DataWarehouse\Data\BatchDataset $dataSet
     * @param string $format
     * @return string Path to file that was written to.
     * @throws \Exception If writing the data fails.
     */
    public function writeDataSetToFile(BatchDataset $dataSet, $format)
    {
        $this->logger->info([
            'module' => self::LOG_MODULE,
            'message' => 'Writing data to file',
            'format' => $format
        ]);

        try {
            $tmpDir = sys_get_temp_dir();
            $dataFile = tempnam($tmpDir, 'batch-export-');

            if ($dataFile === false) {
                throw new Exception(sprintf(
                    'Failed to create temporary file in directory "%s"',
                    $tmpDir
                ));
            }

            $fileWriter = $this->fileWriterFactory->createFileWriter(
                $format,
                $dataFile
            );

            $this->logger->debug([
                'module' => self::LOG_MODULE,
                'message' => 'Created file writer',
                'file_writer' => $fileWriter
            ]);

            $fileWriter->writeRecord($dataSet->getHeader());

            foreach ($dataSet as $record) {
                $fileWriter->writeRecord($record);
            }

            $fileWriter->close();

            return $dataFile;
        } catch (Exception $e) {
            $this->logger->err([
                'module' => self::LOG_MODULE,
                'message' => $e->getMessage(),
                'stacktrace' => $e->getTraceAsString()
            ]);
            throw new Exception('Failed to write data set to file', 0, $e);
        }
    }

    /**
     * Create a zip file containing a single file.
     *
     * @param string $dataFile Path to file that will be put in the zip file.
     * @param array $request Batch export request data.
     * @return string Zip file path.
     * @throws \Exception If creating the zip file fails.
     */
    public function createZipFile($dataFile, array $request)
    {
        $zipFile = $this->getExportDataFilePath($request['id']);

        $this->logger->info([
            'module' => self::LOG_MODULE,
            'message' => 'Creating zip file',
            'batch_export_request.id' => $request['id'],
            'data_file' => $dataFile,
            'zip_file' => $zipFile
        ]);

        try {
            $zip = new ZipArchive();
            $zipOpenCode = $zip->open($zipFile, ZipArchive::CREATE);

            if ($zipOpenCode !== true) {
                throw new Exception(sprintf(
                    'Failed to open zip file "%s", error code "%s"',
                    $zipFile,
                    $zipOpenCode
                ));
            }

            // Override the name of the temporary data file with the proper
            // name that will be used in the archive file.
            $localName = $this->getDataFileName($request);

            if (!$zip->addFile($dataFile, $localName)) {
                throw new Exception(sprintf(
                    'Failed to add file "%s" to zip file "%s"',
                    $dataFile,
                    $zipFile
                ));
            }

            $readmeText = $this->getReadmeText($request['realm']);
            if (!$zip->addFromString('README.txt', $readmeText)) {
                throw new Exception(sprintf(
                    'Failed to add "README.txt" to zip file "%s"',
                    $dataFile,
                    $zipFile
                ));
            }

            if (!$zip->close()) {
                throw new Exception(sprintf(
                    'Failed to close zip file "%s"',
                    $zipFile
                ));
            }

            return $zipFile;
        } catch (Exception $e) {
            $this->logger->err([
                'module' => self::LOG_MODULE,
                'message' => $e->getMessage(),
                'stacktrace' => $e->getTraceAsString()
            ]);
            throw new Exception('Failed to create zip file', 0, $e);
        }
    }

    /**
     * Remove a batch export data file.
     *
     * @param int $id Export request primary key.
     * @throws \Exception If removing the file fails.
     */
    public function removeExportFile($id)
    {
        $zipFile = $this->getExportDataFilePath($id);

        $this->logger->info([
            'module' => self::LOG_MODULE,
            'message' => 'Removing export file',
            'batch_export_request.id' => $id,
            'zip_file' => $zipFile
        ]);

        if (!unlink($zipFile)) {
            throw new Exception(sprintf('Failed to delete "%s"', $zipFile));
        }
    }

    /**
     * Remove all data files corresponding to deleted requests.
     *
     * @param array $deletedRequestIds Request IDs for "Deleted" export
     *   files.
     */
    public function removeDeletedRequests(array $deletedRequestIds)
    {
        foreach ($deletedRequestIds as $id) {
            $exportFile = $this->getExportDataFilePath($id);
            if (is_file($exportFile)) {
                $this->logger->info([
                    'module' => self::LOG_MODULE,
                    'message' => 'Removing export file',
                    'batch_export_request.id' => $id,
                    'zip_file' => $exportFile
                ]);
                if (!unlink($exportFile)) {
                    throw new Exception(sprintf(
                        'Failed to delete "%s"',
                        $exportFile
                    ));
                }
            }
        }
    }

    /**
     * Get the contents for README.txt for a realm.
     *
     * @param string $realm The name of a realm.
     * @return string
     */
    private function getReadmeText($realm)
    {
        $fields = $this->rawStatsConfig->getBatchExportFieldDefinitions($realm);

        $text = "{$realm} Realm Fields\n\n";

        foreach ($fields as $field) {
            $text .= sprintf(
                "%s: %s\n",
                $field['name'],
                $field['documentation']
            );
        }

        return $text;
    }
}
