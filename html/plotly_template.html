<!DOCTYPE HTML>
<html lang="en">
    <head>

        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>Plotly Template</title>

        <style type="text/css">html,body{margin:0px;height:100%;}</style>
        <script type="text/javascript" src="_html_dir_/gui/lib/jquery/jquery-1.12.4.min.js"></script>
        <script type="text/javascript" src="_html_dir_/gui/js/StringExtensions.js"></script>

        <script type="text/javascript" src="_html_dir_/gui/lib/moment/moment.min.js"></script>
        <script type="text/javascript" src="_html_dir_/gui/lib/moment-timezone/moment-timezone-with-data.min.js"></script>
        <script type="text/javascript" src="_html_dir_/gui/lib/plotly/plotly-2.29.1.min.js"></script>

        <script type="text/javascript" src="_html_dir_/gui/js/libraries/PlotlyUtilities.js"></script>

    </head>

    <body>

        <div id="container" class="plotly"></div>
        <script type="text/javascript">
        let Ext = {
            namespace: function () {}
        };
        let XDMoD = {
            utils: {}
        };

        $(document).ready(function () {
            // _ chartOptions _ is a macro that is substituted by \xd_charting\exportChart()
            let inputChartOptions = _chartOptions_;
            const args = {
                mainTitleFontSize: inputChartOptions.chartTitleSize,
                axisTitleFontSize: inputChartOptions.axisTitleSize,
                axisLabelFontSize: inputChartOptions.axisTickSize,
                lineWidth: inputChartOptions.lineWidth
            };
            let chartOptions = {};
            // Chart will be fully configured if export call came from non-supremm module tab
            if (inputChartOptions.layout) {
                chartOptions = inputChartOptions;
                const isEmpty = (!chartOptions.data) || (chartOptions.data && chartOptions.data.length === 0);
                // Configure plot for 'No Data' image. We want to wipe the layout object except for a couple things
                if (isEmpty) {
                    const errorConfig = getNoDataErrorConfig();
                    const { width } = chartOptions.layout;
                    const { height } = chartOptions.layout;
                    // Save the title and subtitle except for thumbnail plots
                    let margin;
                    let titleAndSubtitle;
                    if (chartOptions.layout.annotations) {
                        margin = chartOptions.layout.margin;
                        titleAndSubtitle = chartOptions.layout.annotations.slice(0, 2);
                    }
                    chartOptions.layout = errorConfig;
                    chartOptions.layout.width = width;
                    chartOptions.layout.height = height;
                    chartOptions.layout.annotations = [];
                    // Category chart summary view needs adjustments
                    if (chartOptions.realmOverview) {
                        chartOptions.layout.images[0].sizex = 4;
                        chartOptions.layout.images[0].sizey = 4;
                        chartOptions.layout.images[0].y = 2.5;
                    }
                    if (margin && titleAndSubtitle) {
                        chartOptions.layout.margin = margin;
                        chartOptions.layout.annotations = titleAndSubtitle;
                    }
                } else {
                    if (chartOptions.data[0].type === 'pie') {
                        chartOptions.layout.margin.t += 30;
                    }

                    for (let i = 0; i < chartOptions.data.length; i++) {
                        // Rollback constrain for bar chart text font size
                        chartOptions.data[i]['constraintext'] = 'none';
                    }

                    chartOptions.data.sort((trace1, trace2) => {
                        if (chartOptions.layout.barmode !== 'group') {
                            return Math.sign(trace2.zIndex - trace1.zIndex) || Math.sign(trace2.traceorder - trace1.traceorder);
                        }
                        const res = Math.sign(trace1.zIndex - trace2.zIndex) || Math.sign(trace1.traceorder - trace2.traceorder);
                        return res;
                    });

                }
            }
            else {
                chartOptions = generateChartOptions(inputChartOptions, args);
            }

            chartOptions.layout['width'] = _width_;
            chartOptions.layout['height'] = _height_;

            Plotly.newPlot('container', chartOptions.data, chartOptions.layout, { staticPlot: true } );

            const chartDiv = document.getElementById('container');

            if (chartDiv) {
                Plotly.relayout('container', {});
            }

            chartDiv.once('plotly_relayout', (evt) => {
                if (chartOptions.layout.appkernels) {
                    const appKernelsDiv = document.getElementById('app_kernels');
                    const legendEntries = appKernelsDiv.getElementsByClassName('groups');
                    for (let i = 0; i < legendEntries.length; i++) {
                        for (let j = 0; j < legendEntries[i].children.length; j++) {
                            if (legendEntries[i].children[j].textContent === 'Change Indicator') {
                                const changeIndicatorIcon = legendEntries[i].children[j].children[1];
                                changeIndicatorIcon.innerHTML = '<image href="/gui/images/exclamation_ak.png" x="15" y="-12" width="20" height="20">';
                            }
                        }
                    }
                }

                if (chartOptions.layout.annotations.length === 0){
                    return;
                }

                let lineSplit = (s, wrapWidth) => {
                    return s.match(new RegExp(`([^\\n]{1,${wrapWidth}})(?=\\s|$)`, 'g'))
                }

                let topLegend = (layout) => {
                    return  (layout.legend.xanchor == 'center' &&
                             layout.legend.yanchor == 'top'    &&
                             layout.legend.yref != 'paper')
                }
                let adjustTitles = (layout) => {
                    if (layout.annotations && layout.annotations.length == 0) {
                        return 0;
                    }
                    let subtitle = layout.annotations[1];
                    const len = subtitle.text.length;
                    let subtitleLineCount = 0;
                    if (len > 0) {
                       const axWidth = _width_ -  layout.margin.l - layout.margin.r;
                       const subtitle_lines = lineSplit(subtitle.text, Math.trunc(axWidth / 8));
                       layout.margin.t = 45 + (subtitle_lines.length * 15);
                       layout.annotations[1].text = subtitle_lines.join('<br />');
                       if (topLegend(layout)) {
                           layout.legend.y = 0.95 - (0.025 * subtitle_lines.length);
                           layout.annotations[1].yshift = (17 * subtitle_lines.length) * -1;
                       }
                       subtitleLineCount = subtitle_lines.length;
                    }
                    else {
                        if (topLegend(layout)) {
                            layout.margin.t = 45 + 20;
                        }
                    }

                    return subtitleLineCount;
                }
                const topCenter = topLegend(chartOptions.layout);
                const subtitleLineCount = adjustTitles(chartOptions.layout);
                const marginTop = (topCenter || subtitleLineCount > 0) ? chartOptions.layout.margin.t : chartDiv._fullLayout._size.t;
                const marginRight = chartDiv._fullLayout._size.r;
                const marginLeft = chartDiv._fullLayout._size.l;
                const legendHeight = (topCenter && !(chartOptions.layout.height <= 550)) ? chartDiv._fullLayout.legend._height : 0;
                const titleHeight = 31;
                const subtitleHeight = 15;
                let creditsHeight = 0;
                if (subtitleLineCount > 0) {
                    creditsHeight = (15 * subtitleLineCount);
                    if (topCenter) {
                        creditsHeight -= 15;
                    }
                }
                let titleIndex = -1;
                let subtitleIndex = -1;
                let creditsIndex = -1;
                let restrictedIndex = -1;

                for (let i = 0; i < chartOptions.layout.annotations.length; i++) {
                    const name = chartOptions.layout.annotations[i].name;
                    switch (name) {
                        case 'title':
                            titleIndex = i;
                        case 'subtitle':
                            subtitleIndex = i;
                        case 'credits':
                            creditsIndex = i;
                        case 'Restricted Data Warning':
                            restrictedIndex = i;
                        default:
                    }
                }

                const update = {};

                if (titleIndex > -1) {
                    update[`annotations[${subtitleIndex}].yshift`] = (marginTop + legendHeight) - titleHeight;
                }

                if (subtitleIndex > -1) {
                    update[`annotations[${subtitleIndex}].yshift`] = ((marginTop + legendHeight) - titleHeight) - (subtitleHeight * subtitleLineCount);
                }

                const marginBottom = chartDiv._fullLayout._size.b;
                const plotAreaHeight = chartDiv._fullLayout._size.h;
                let pieChartYShift = 0;
                let pieChartXShift = 0;
                if (chartDiv._fullData.length !== 0 && chartDiv._fullData[0].type === 'pie') {
                    pieChartYShift = subtitleLineCount > 0 ? 30 : 0;
                    pieChartXShift = subtitleLineCount > 0 ? 2 : 1;
                }

                if (creditsIndex > -1) {
                    update[`annotations[${creditsIndex}].yshift`] = (plotAreaHeight + marginBottom) * -1 + creditsHeight - pieChartYShift;
                    update[`annotations[${creditsIndex}].xshift`] = (marginRight/2) - pieChartXShift;
                }
                if (restrictedIndex > -1) {
                   update[`annotations[${restrictedIndex}].yshift`] = (plotAreaHeight + marginBottom) * -1 + creditsHeight - pieChartYShift;
                   update[`annotations[${restrictedIndex}].xshift`] = ((marginLeft/2) - pieChartXShift) * -1;
                }

                Plotly.relayout('container', update);

            });
        });

        </script>

    </body>
</html>
